<script>
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const scoreDisplay = document.getElementById("score");
  const gameOverText = document.getElementById("gameOver");
  const winMessage = document.getElementById("winMessage");
  const skinMenu = document.getElementById("skinMenu");
  const skinButton = document.getElementById("skinButton");
  const closeMenu = document.getElementById("closeMenu");

  const skins = [
    { name: "Mangonio", file: "mangonio.png" },
    { name: "Mangonio Fino", file: "mangoniofino.png" },
    { name: "René", file: "René.png" },
    { name: "Gil", file: "gil.png" },
    { name: "Pablito", file: "pablito.png" },
    { name: "Kuchau", file: "kuchau.png" },
    { name: "Polariza", file: "polariza.png" },
    { name: "Gil Shiny", file: "GilShiny.png", requiresCode: true },
    { name: "Golden Mangonio", file: "GoldenMangonio.png" },
    { name: "IronGonio", file: "IronGonio.png" },
    { name: "mangonio.exe", file: "mangonio.exe.png" }
  ];

  let mangonioImg = new Image();
  mangonioImg.src = skins[0].file;

  let mangonio, obstacles, coins, speed, frame, score, gameOver, youWin;
  let speedStartTime = 0;
  let isCrouching = false;

  function resetGame() {
    mangonio = {
      x: 60,
      y: canvas.height - 60 - 70,
      width: 50,
      height: 70,
      vy: 0,
      jumpPower: -13,
      gravity: 0.9,
      grounded: true,
      hitboxReduction: 0.9,
      normalHeight: 70,
      crouchHeight: 35
    };

    obstacles = [];
    coins = [];
    speed = 6;
    frame = 0;
    score = 0;
    gameOver = false;
    youWin = false;
    speedStartTime = performance.now();
    gameOverText.style.display = "none";
    winMessage.style.display = "none";
    scoreDisplay.textContent = "Puntos: 0";

    requestAnimationFrame(update);
  }

  function drawFloor() {
    ctx.fillStyle = "#f5deb3";
    ctx.fillRect(0, canvas.height - 60, canvas.width, 60);
  }

  function drawMangonio() {
    ctx.drawImage(mangonioImg, mangonio.x, mangonio.y, mangonio.width, mangonio.height);
  }

  function drawCactus(cactus) {
    ctx.fillStyle = "#2e8b57";
    ctx.fillRect(cactus.x, cactus.y, cactus.width, cactus.height);
    ctx.fillRect(cactus.x - 10, cactus.y + 10, 8, 20);
    ctx.fillRect(cactus.x + cactus.width, cactus.y + 10, 8, 20);
  }

  function drawCoin(coin) {
    ctx.fillStyle = "gold";
    ctx.beginPath();
    ctx.arc(coin.x, coin.y, coin.radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = "orange";
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  function drawWin() {
    ctx.font = "30px Arial";
    ctx.fillStyle = "purple";
    ctx.fillText("🎂", canvas.width / 2 - 15, canvas.height / 2);
    for (let i = 0; i < 100; i++) {
      ctx.fillStyle = `hsl(${Math.random() * 360}, 100%, 50%)`;
      ctx.beginPath();
      ctx.arc(Math.random() * canvas.width, Math.random() * canvas.height, 3, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Función para verificar colisiones simples entre rectángulo y círculo
  function rectCircleColliding(rect, circle) {
    const distX = Math.abs(circle.x - rect.x - rect.width / 2);
    const distY = Math.abs(circle.y - rect.y - rect.height / 2);

    if (distX > (rect.width / 2 + circle.radius)) { return false; }
    if (distY > (rect.height / 2 + circle.radius)) { return false; }

    if (distX <= (rect.width / 2)) { return true; }
    if (distY <= (rect.height / 2)) { return true; }

    const dx = distX - rect.width / 2;
    const dy = distY - rect.height / 2;
    return (dx * dx + dy * dy <= (circle.radius * circle.radius));
  }

  function update() {
    if (gameOver || youWin) return;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawFloor();

    if (isCrouching && mangonio.grounded) {
      mangonio.height = mangonio.crouchHeight;
      mangonio.y = canvas.height - 60 - mangonio.height;
    } else if (mangonio.height !== mangonio.normalHeight) {
      mangonio.height = mangonio.normalHeight;
      mangonio.y = canvas.height - 60 - mangonio.height;
    }

    mangonio.vy += mangonio.gravity;
    mangonio.y += mangonio.vy;
    if (mangonio.y >= canvas.height - 60 - mangonio.height) {
      mangonio.y = canvas.height - 60 - mangonio.height;
      mangonio.vy = 0;
      mangonio.grounded = true;
    }

    drawMangonio();

    // Generar cactus cada 60 frames
    if (frame % 60 === 0) {
      obstacles.push({ x: canvas.width, y: canvas.height - 110, width: 20, height: 50 });
    }

    // Mover cactus y detectar colisiones
    for (let i = 0; i < obstacles.length; i++) {
      let c = obstacles[i];
      c.x -= speed;
      drawCactus(c);

      const shrink = 0.9;
      const mx = mangonio.x + mangonio.width * (1 - mangonio.hitboxReduction) / 2;
      const my = mangonio.y + mangonio.height * (1 - mangonio.hitboxReduction) / 2;
      const mw = mangonio.width * mangonio.hitboxReduction;
      const mh = mangonio.height * mangonio.hitboxReduction;

      const cx = c.x + (1 - shrink) * c.width / 2;
      const cw = c.width * shrink;

      if (mx < cx + cw && mx + mw > cx && my + mh > c.y) {
        gameOver = true;
        gameOverText.style.display = "block";
        return;
      }
    }

    // Eliminar cactus fuera de pantalla
    obstacles = obstacles.filter(c => c.x + c.width > 0);

    // --- Lógica para generar monedas entre cada par de cactus cada 2 cactus pasados ---
    // Aquí contamos cuántos cactus ya pasaron de la posición de mangonio
    // Cada vez que pasamos 2 cactus, generamos una moneda entre esos dos
    // Evitamos repetir moneda usando un contador

    // Variables para control de monedas y cactus pasados
    // Usamos frame para chequear sólo cada frame
    if (!update.passedCactusCount) update.passedCactusCount = 0;
    if (!update.lastPassedIndex) update.lastPassedIndex = -1;

    // Revisamos si un cactus ya pasó al jugador
    // Para eso, verificamos que cactus.x + cactus.width < mangonio.x
    obstacles.forEach((c, i) => {
      if (!c.passed && (c.x + c.width < mangonio.x)) {
        c.passed = true;
        update.passedCactusCount++;
      }
    });

    // Cuando pasamos 2 cactus, generamos la moneda entre ellos
    // Solo si la moneda para ese par no fue creada (usaremos lastPassedIndex)
    if (update.passedCactusCount >= 2) {
      // Obtenemos los dos cactus más recientes que pasaron (en orden)
      const passedCactuses = obstacles.filter(c => c.passed);
      if (passedCactuses.length >= 2) {
        // Tomamos los dos cactus más antiguos pasados para crear la moneda entre ellos
        let c1 = passedCactuses[passedCactuses.length - 2];
        let c2 = passedCactuses[passedCactuses.length - 1];

        // Solo crear moneda si no existe una para estos cactus
        // Para evitar repeticiones, guardamos el último índice de cactus que creó moneda
        if (update.lastPassedIndex < c2.x) {
          // Posición media en x entre ambos cactus
          const coinX = (c1.x + c2.x + c1.width) / 2;
          // Altura de la moneda justo encima del suelo (similar altura cactus)
          const coinY = canvas.height - 110 - 20;
          coins.push({ x: coinX, y: coinY, radius: 10 });
          update.lastPassedIndex = c2.x;
          update.passedCactusCount = 0;
        }
      }
    }

    // Dibujar y mover monedas hacia la izquierda (igual que cactus)
    for (let i = 0; i < coins.length; i++) {
      let coin = coins[i];
      coin.x -= speed;
      drawCoin(coin);

      // Detectar colisión entre mangonio y moneda
      if (rectCircleColliding(mangonio, coin)) {
        score += 10; // Cada moneda suma 10 puntos extra
        coins.splice(i, 1);
        i--;
        scoreDisplay.textContent = `Puntos: ${score}`;
      }
    }

    // Eliminar monedas fuera de pantalla
    coins = coins.filter(c => c.x + c.radius > 0);

    frame++;
    const elapsedSeconds = (performance.now() - speedStartTime) / 1000;
    if (elapsedSeconds > 10 && speed < 8) speed = 8;

    if (frame % 5 === 0) {
      score++;
      scoreDisplay.textContent = `Puntos: ${score}`;
      if (score % 100 === 0 && speed < 16) speed += 0.5;
    }

    if (score >= 5000) {
      youWin = true;
      winMessage.style.display = "block";
      drawWin();
      return;
    }

    requestAnimationFrame(update);
  }

  let crouchKeys = new Set();

  window.addEventListener("keydown", e => {
    if ((e.code === "Space" || e.code === "ArrowUp") && mangonio.grounded && !gameOver && !youWin) {
      mangonio.vy = mangonio.jumpPower;
      mangonio.grounded = false;
    }
    if (e.code === "ArrowDown" || e.code === "KeyB") {
      crouchKeys.add(e.code);
      isCrouching = true;
    }
    if (e.code === "KeyR" && (gameOver || youWin)) {
      resetGame();
    }
  });

  window.addEventListener("keyup", e => {
    if (e.code === "ArrowDown" || e.code === "KeyB") {
      crouchKeys.delete(e.code);
      if (crouchKeys.size === 0) {
        isCrouching = false;
      }
    }
  });

  function showSkinMenu() {
    skinMenu.innerHTML = '<button id="closeMenu">X</button>';
    skins.forEach(skin => {
      const div = document.createElement("div");
      div.className = "skin-option";
      div.innerHTML = `
        <img src="${skin.file}" alt="${skin.name}" />
        <div>${skin.name}</div>
        <button>Seleccionar</button>
      `;
      div.querySelector("button").onclick = () => {
        if (skin.requiresCode) {
          const code = prompt("Introduce el código para desbloquear esta skin:");
          if (code !== "GilGuapo") return alert("Código incorrecto");
        }
        mangonioImg.src = skin.file;
        skinMenu.style.display = "none";
      };
      skinMenu.appendChild(div);
    });
    document.getElementById("closeMenu").onclick = () => skinMenu.style.display = "none";
    skinMenu.style.display = "block";
  }

  skinButton.onclick = showSkinMenu;
  mangonioImg.onload = resetGame;
</script>
