<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Snake Avanzado</title>
  <style>
    body {
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #eee;
      transition: background 0.3s;
    }
    canvas {
      border: 3px solid #444;
      background: #fff;
      transition: background 0.3s;
    }
    #darkToggle {
      position: absolute;
      top: 10px;
      right: 10px;
      background: #ddd;
      padding: 6px 12px;
      font-family: sans-serif;
      font-size: 14px;
      border-radius: 5px;
      cursor: pointer;
      border: none;
    }
    body.dark {
      background: #111;
    }
    body.dark canvas {
      background: #222;
    }
  </style>
</head>
<body>
<button id="darkToggle">Modo Oscuro: OFF</button>
<canvas id="game" width="400" height="400"></canvas>
<audio id="eatSound" src="https://cdn.pixabay.com/audio/2022/03/15/audio_0b9b1d7c69.mp3"></audio>
<audio id="powerSound" src="https://cdn.pixabay.com/audio/2022/03/15/audio_7c2bce4f9c.mp3"></audio>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const darkToggle = document.getElementById("darkToggle");
const eatSound = document.getElementById("eatSound");
const powerSound = document.getElementById("powerSound");

let darkMode = false;
darkToggle.onclick = () => {
  darkMode = !darkMode;
  document.body.classList.toggle("dark", darkMode);
  darkToggle.textContent = `Modo Oscuro: ${darkMode ? 'ON' : 'OFF'}`;
};

const gridSize = 20;
const cols = canvas.width / gridSize;
const rows = canvas.height / gridSize;

let snake = [{x: 10, y: 10}];
let velocity = {x: 1, y: 0};
let apple = {x: 15, y: 10};
let powerUp = null;
let score = 0;
let level = 1;
let tickRate = 150;
let gameOver = false;
let directionQueue = [];

let lastTick = 0;

function resetGame() {
  snake = [{x: 10, y: 10}];
  velocity = {x: 1, y: 0};
  apple = {x: 15, y: 10};
  powerUp = null;
  score = 0;
  level = 1;
  tickRate = 150;
  gameOver = false;
  directionQueue = [];
}

function placeApple() {
  let valid = false;
  while (!valid) {
    apple = {
      x: Math.floor(Math.random() * cols),
      y: Math.floor(Math.random() * rows),
    };
    valid = !snake.some(s => s.x === apple.x && s.y === apple.y);
  }
}

function placePowerUp() {
  if (powerUp !== null) return;
  if (Math.random() < 0.2) {
    let pos;
    do {
      pos = {
        x: Math.floor(Math.random() * cols),
        y: Math.floor(Math.random() * rows),
      };
    } while (snake.some(s => s.x === pos.x && s.y === pos.y));
    powerUp = pos;
  }
}

function updateSnake() {
  const next = {
    x: snake[0].x + velocity.x,
    y: snake[0].y + velocity.y,
  };

  if (
    next.x < 0 || next.y < 0 ||
    next.x >= cols || next.y >= rows ||
    snake.some(p => p.x === next.x && p.y === next.y)
  ) {
    gameOver = true;
    return;
  }

  snake.unshift(next);

  if (next.x === apple.x && next.y === apple.y) {
    score++;
    eatSound.play();
    placeApple();
    if (score % 5 === 0) {
      level++;
      tickRate = Math.max(60, tickRate - 10);
    }
    placePowerUp();
  } else if (powerUp && next.x === powerUp.x && next.y === powerUp.y) {
    score += 3;
    powerSound.play();
    powerUp = null;
  } else {
    snake.pop();
  }
}

document.addEventListener("keydown", e => {
  const d = e.code;
  let newDir = null;
  if (d === "ArrowUp" && velocity.y === 0) newDir = {x: 0, y: -1};
  else if (d === "ArrowDown" && velocity.y === 0) newDir = {x: 0, y: 1};
  else if (d === "ArrowLeft" && velocity.x === 0) newDir = {x: -1, y: 0};
  else if (d === "ArrowRight" && velocity.x === 0) newDir = {x: 1, y: 0};
  if (newDir) directionQueue.push(newDir);
});

function drawSnake() {
  for (let i = 0; i < snake.length; i++) {
    const p = snake[i];
    const hue = (score * 10 + i * 10) % 360;
    ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
    ctx.beginPath();
    ctx.roundRect(p.x * gridSize + 2, p.y * gridSize + 2, gridSize - 4, gridSize - 4, gridSize / 2.5);
    ctx.fill();
  }
}

function draw() {
  requestAnimationFrame(draw);
  const now = performance.now();
  if (now - lastTick < tickRate) return;
  lastTick = now;

  if (gameOver) {
    ctx.fillStyle = darkMode ? "#111" : "#fff";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "#f00";
    ctx.font = "24px sans-serif";
    ctx.fillText("GAME OVER", 120, 180);
    ctx.fillText("Puntos: " + score, 140, 210);
    setTimeout(() => { resetGame(); }, 2000);
    return;
  }

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawSnake();

  // Apple
  ctx.fillStyle = "#e74c3c";
  ctx.beginPath();
  ctx.arc(apple.x * gridSize + gridSize / 2, apple.y * gridSize + gridSize / 2, gridSize / 2 - 2, 0, Math.PI * 2);
  ctx.fill();

  // Power-up
  if (powerUp) {
    ctx.fillStyle = "#f1c40f";
    ctx.fillRect(powerUp.x * gridSize + 4, powerUp.y * gridSize + 4, gridSize - 8, gridSize - 8);
  }

  if (directionQueue.length) velocity = directionQueue.shift();
  updateSnake();
}

CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
  this.beginPath();
  this.moveTo(x + r, y);
  this.lineTo(x + w - r, y);
  this.quadraticCurveTo(x + w, y, x + w, y + r);
  this.lineTo(x + w, y + h - r);
  this.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  this.lineTo(x + r, y + h);
  this.quadraticCurveTo(x, y + h, x, y + h - r);
  this.lineTo(x, y + r);
  this.quadraticCurveTo(x, y, x + r, y);
  this.closePath();
};

resetGame();
draw();
</script>
</body>
</html>
